// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2016 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Package snapstate implements the manager and state aspects responsible for the installation and removal of snaps.
package snapstate

import (
	"fmt"

	"github.com/ubuntu-core/snappy/overlord/state"
)

// SnapManager is responsible for the installation and removal of snaps.
type SnapManager struct {
	state     *state.State
	snapState *managerState
}

// Init implements StateManager.Init.
func (m *SnapManager) Init(s *state.State) error {
	return nil
}

// Ensure implements StateManager.Ensure.
func (m *SnapManager) Ensure() error {
	return nil
}

// Stop implements StateManager.Stop.
func (m *SnapManager) Stop() error {
	return nil
}

// Manager returns a new snap manager.
func Manager() (*SnapManager, error) {
	return &SnapManager{}, nil
}

// Install initiates a change installing snap.
func Install(change *state.Change, snap string) error {
	change.NewTask("download-snap", fmt.Sprintf("Downloading %q", snap))
	change.NewTask("install-snap", fmt.Sprintf("Installing %q", snap))

	var current managerState
	change.State().Get("snaps", &current)
	current.Add(snap)
	change.State().Set("snaps", &current)

	return nil
}

// Remove initiates a change removing snap.
func Remove(change *state.Change, snap string) error {
	change.NewTask("unmount-snap", fmt.Sprintf("Unmounting %q", snap))
	change.NewTask("remove-autogenerated", fmt.Sprintf("Removing auto-generated files for %q", snap))

	mgr, _ := Manager()
	var current managerState
	mgr.state.Get("snaps", &current)
	current.Del(snap)
	mgr.state.Set("snaps", &current)

	return nil
}

// managerState keeps the state of all snaps on the system
type managerState struct {
	Snaps []*snapState
}

func (m *managerState) Add(snap string) {
	for _, st := range m.Snaps {
		// already part of the state, nothing to do
		if st.Name == snap {
			return
		}
	}
	m.Snaps = append(m.Snaps, &snapState{Name: snap})
}

func (m *managerState) Del(snap string) {
	for i, st := range m.Snaps {
		if st.Name == snap {
			m.Snaps = append(m.Snaps[:i], m.Snaps[i+1:]...)
			return
		}
	}
}
